<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>2-Letter Key Quiz</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .no-wrap-grid {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }
  </style>

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="apple-touch-icon" href="./src/favicon-blind.png">
  
</head>
<body class="bg-gray-100 text-gray-800">
  <div id="app" class="max-w-4xl mx-auto mt-10 p-4">
    <h1 class="text-2xl font-bold text-center">
      ðŸ«  2-Letter Key Memorization
    </h1>
    <div class="my-3 flex items-center justify-center gap-4">
      <button
        v-if="mode == 'study'"
        @click="mode = 'self'"
        class="text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded text-gray-800"
        title="Force reload from server"
      >
        Self Mode
      </button>
      <button
        v-if="mode == 'self'"
        @click="mode = 'Study'"
        class="text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded text-gray-800"
        title="Force reload from server"
      >
        Study Mode
      </button>
      <button
        @click="reloadData"
        class="text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded text-gray-800"
        title="Force reload from server"
      >
        ðŸ”„ Reload Cache
      </button>
      <button
        @click="hideAll"
        class="text-sm bg-gray-200 hover:bg-gray-300 px-3 py-1 rounded text-gray-800"
        title="Force reload from server"
      >
        Hide All
      </button>
    </div>

    <div v-if="loading" class="text-center text-gray-500">Loading...</div>

    <div v-else>
      <!-- Study Mode -->
      <div v-if="mode === 'study'">
        <div class="grid gap-2 no-wrap-grid">
          <template
            v-for="(item, index) in currentSet"
            :key="index">
            <div
              @click="reveal(index)"
              class="bg-white shadow rounded-lg p-2 border border-gray-200 text-center"
            >
              <div class="text-lg font-bold uppercase text-gray-800">{{ item.key }}</div>
              <div v-if="revealed[index]" class="text-sm text-gray-600 mt-1">{{ item.value }}</div>
            </div>
          </template>
        </div>

        <div class="text-center mt-6">
          <button
            @click="startRecall"
            class="bg-orange-600 text-white px-6 py-3 rounded hover:bg-orange-700 transition shadow-md">
            Ready (Hide and Input)
          </button>
        </div>
      </div>

      <div v-else-if="mode === 'self'">
        <div class="text-center">
          <input 
            class="w-full h-16 p-3 border rounded mt-4 text-center text-lg tracking-wider"
            type="Type your input"
            v-model="selfInput"
          >
          <button 
            class="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 transition mt-5"
            @click="registerInput"
          >Enter</button>
        </div>
      </div>

      <!-- Recall Mode -->
      <div v-else-if="mode === 'recall'" class="text-center">
        <textarea
          v-model="userInput"
          class="w-full h-24 p-3 border rounded mt-4 text-center text-lg tracking-wider"
          placeholder="Type the 18-letter combined key like abcrgx..."
        ></textarea>

        <div class="mt-4 space-x-4">
          <button
            v-if="result.length == 0"
            @click="check"
            class="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 transition">
            Check
          </button>

          <button
            v-if="result.length > 0"
            @click="reset('study')"
            class="bg-gray-600 text-white px-6 py-2 rounded hover:bg-gray-700 transition">
            New Random
          </button>

          <button
            v-if="result.length > 0"
            @click="reset('self')"
            class="bg-gray-600 text-white px-6 py-2 rounded hover:bg-gray-700 transition">
            New Input
          </button>
        </div>

        <div v-if="result.length > 0" class="mt-6 grid gap-2 no-wrap-grid">
          <div
            v-for="(pair, index) in result"
            :key="index"
            class="p-2 rounded text-center text-white font-bold"
            :class="pair.correct ? 'bg-green-500' : 'bg-red-500'"
          >
            <div class="text-sm">Your:</div>
            <div class="text-lg tracking-widest">{{ pair.user }}</div>
            <div class="text-sm mt-1">Answer:</div>
            <div class="text-lg tracking-widest">{{ pair.actual }}</div>
            <div class="text-xs mt-1 font-normal text-white/80">{{ pair.value }}</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.prod.js"></script>
  <script>
    const { createApp, ref, onMounted } = Vue;

    createApp({
      setup() {
        const baseURL = "https://script.google.com/macros/s/AKfycbwkTs-I234XYgnTRPz6NORJxYYurYUaegYO1zoumHzTAulg1mnupw5yDBmGPom6fVDwbA/";
        const keywordMap = ref({});
        const loading = ref(true);
        const quizPairs = ref([]);
        const currentSet = ref([]);
        const correctKeys = ref([]);
        const revealed = ref([]);
        const userInput = ref("");
        const result = ref([]);
        const mode = ref("study");
        const selfInput = ref("");

        const CACHE_KEY = "keywordCache";
        const CACHE_EXPIRY = .5 * 60 * 60 * 1000; // 1 hours

        const loadFromCache = () => {
          const raw = localStorage.getItem(CACHE_KEY);
          if (!raw) return null;
          try {
            const parsed = JSON.parse(raw);
            const now = Date.now();
            if (now - parsed.timestamp < CACHE_EXPIRY) {
              return parsed.data;
            }
          } catch (e) {
            console.warn("Cache parsing failed:", e);
          }
          return null;
        };

        const saveToCache = (data) => {
          localStorage.setItem(CACHE_KEY, JSON.stringify({ data, timestamp: Date.now() }));
        };

        const get2LetterPairs = (map) => {
          const pairs = [];
          const alphabet = 'abcdefghijklmnopqrstuvwxyz';
          for (let rowKey in map) {
            const row = map[rowKey];
            row.forEach((value, colIndex) => {
              if (colIndex >= 0 && colIndex < 26) {
                const secondLetter = alphabet[colIndex];
                const key = rowKey.toLowerCase() + secondLetter;
                pairs.push({ key, value });
              }
            });
          }
          return pairs;
        };

        const fetchKeywordMap = async (force = false) => {
          if (!force) {
            const cached = loadFromCache();
            if (cached) {
              keywordMap.value = cached;
              quizPairs.value = get2LetterPairs(cached);
              pickRandomSet("study");
              loading.value = false;
              return;
            }
          }
          try {
            const res = await fetch(`${baseURL}exec?action=getKeywordMap`);
            const json = await res.json();
            if (json.success) {
              keywordMap.value = json.data;
              saveToCache(json.data);
              quizPairs.value = get2LetterPairs(json.data);
              pickRandomSet("study");
            }
          } catch (err) {
            console.error("Fetch failed:", err);
          } finally {
            loading.value = false;
          }
        };

        const pickRandomSet = (newMode) => {
          const selected = [];
          const used = new Set();
          while (selected.length < 9 && used.size < quizPairs.value.length) {
            const rand = Math.floor(Math.random() * quizPairs.value.length);
            if (!used.has(rand)) {
              selected.push(quizPairs.value[rand]);
              used.add(rand);
            }
          }
          currentSet.value = selected;
          correctKeys.value = selected.map(i => i.key);
          revealed.value = Array(selected.length).fill(false);
          userInput.value = "";
          result.value = [];
          mode.value = newMode; 
        };

        const startRecall = () => {
          mode.value = "recall";
        };

        const reveal = (index) => {
          revealed.value[index] = !revealed.value[index];
        };

        const hideAll = () => {
          revealed.value = revealed.value.map(() => false);
        };


        const check = () => {
          const input = userInput.value.trim().toLowerCase();
          const userKeys = [];
          for (let i = 0; i < input.length; i += 2) {
            userKeys.push(input.slice(i, i + 2));
          }
          result.value = correctKeys.value.map((correct, i) => ({
            actual: correct,
            user: userKeys[i] || "--",
            correct: userKeys[i] === correct,
            value: currentSet.value[i]?.value || ""
          }));
        };

        const reset = (newMode) => pickRandomSet(newMode);

        const reloadData = () => {
          loading.value = true;
          fetchKeywordMap(true);
        };

        const registerInput = () => {
            const input = selfInput.value.trim().toLowerCase();
            if (!input) return;

            const pairs = [];
            for (let i = 0; i < input.length; i += 2) {
                pairs.push(input.slice(i, i + 2));
            }

            const pairMap = {};
            quizPairs.value.forEach(item => {
                pairMap[item.key] = item;
            });

            const matched = pairs
                .map(key => {
                    if (pairMap[key]) {
                        return pairMap[key];          // existing 2-letter match
                    } else {
                        return { key: key, value: key }; // leftover single letter or no match
                    }
                })

            currentSet.value = matched;
            correctKeys.value = currentSet.value.map(i => i.key);
            revealed.value = Array(currentSet.value.length).fill(false);

            selfInput.value = "";
            mode.value = "study";
        };



        onMounted(() => {
          fetchKeywordMap();
        });

        return {
          loading,
          currentSet,
          revealed,
          userInput,
          result,
          mode,
          selfInput,

          startRecall,
          check,
          reset,
          reveal,
          reloadData,
          hideAll,
          registerInput
        };
      }
    }).mount("#app");
  </script>
</body>
</html>
